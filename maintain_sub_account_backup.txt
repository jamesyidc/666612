def maintain_sub_account():
    """å­è´¦æˆ·ç»´æŠ¤é”šç‚¹å•ï¼šä¹°å…¥100Uå¹¶ç«‹å³å¹³æ‰"""
    try:
        import requests
        import hmac
        import base64
        import hashlib
        import json as json_lib
        from datetime import datetime, timezone
        import pytz
        import os
        import math
        import time
        
        data = request.json
        account_name = data.get('account_name')
        inst_id = data.get('inst_id')
        pos_side = data.get('pos_side')
        pos_size = float(data.get('pos_size', 0))
        
        # æ–°å¢å‚æ•°ï¼šæ”¯æŒåŠ¨æ€ç»´æŠ¤é‡‘é¢å’Œç›®æ ‡ä¿è¯é‡‘
        maintenance_amount = float(data.get('amount', 100))  # ç»´æŠ¤é‡‘é¢ï¼Œé»˜è®¤100U
        target_margin = float(data.get('target_margin', 10))  # ç›®æ ‡ä¿è¯é‡‘ï¼Œé»˜è®¤10U
        maintenance_count = int(data.get('maintenance_count', 0))  # å½“å‰ç»´æŠ¤æ¬¡æ•°
        
        if not all([account_name, inst_id, pos_side]):
            return jsonify({
                'success': False,
                'message': 'ç¼ºå°‘å¿…è¦å‚æ•°'
            })
        
        # è¯»å–å­è´¦æˆ·é…ç½®
        with open('sub_account_config.json', 'r', encoding='utf-8') as f:
            config = json_lib.load(f)
        
        # æŸ¥æ‰¾å¯¹åº”çš„å­è´¦æˆ·
        sub_account = None
        for acc in config.get('sub_accounts', []):
            if acc['account_name'] == account_name:
                sub_account = acc
                break
        
        if not sub_account:
            return jsonify({
                'success': False,
                'message': f'æœªæ‰¾åˆ°å­è´¦æˆ·: {account_name}'
            })
        
        api_key = sub_account['api_key']
        secret_key = sub_account['secret_key']
        passphrase = sub_account['passphrase']
        
        # æ£€æŸ¥ä»Šæ—¥ç»´æŠ¤æ¬¡æ•°
        maintenance_file = 'sub_account_maintenance.json'
        beijing_tz = pytz.timezone('Asia/Shanghai')
        now_beijing = datetime.now(beijing_tz)
        today_date = now_beijing.strftime('%Y-%m-%d')
        
        # è¯»å–ç»´æŠ¤è®°å½•
        if os.path.exists(maintenance_file):
            with open(maintenance_file, 'r', encoding='utf-8') as f:
                maintenance_data = json_lib.load(f)
        else:
            maintenance_data = {}
        
        record_key = f"{account_name}_{inst_id}_{pos_side}"
        record = maintenance_data.get(record_key, {})
        
        # æ£€æŸ¥ä»Šæ—¥ç»´æŠ¤æ¬¡æ•°
        today_count = 0
        if record.get('date') == today_date:
            today_count = record.get('count', 0)
        
        max_count = sub_account.get('max_maintenance_count', 3)
        if today_count >= max_count:
            return jsonify({
                'success': False,
                'message': f'ä»Šæ—¥ç»´æŠ¤æ¬¡æ•°å·²è¾¾ä¸Šé™({max_count}æ¬¡)ï¼Œè¯·æ˜å¤©å†è¯•æˆ–æ‰‹åŠ¨æ¸…é›¶',
                'today_count': today_count,
                'max_count': max_count
            })
        
        # OKEx APIç­¾åå‡½æ•°
        def generate_signature(timestamp, method, request_path, body=''):
            if body:
                body = json_lib.dumps(body)
            message = timestamp + method + request_path + body
            mac = hmac.new(
                bytes(secret_key, encoding='utf8'),
                bytes(message, encoding='utf-8'),
                digestmod=hashlib.sha256
            )
            return base64.b64encode(mac.digest()).decode()
        
        def get_headers(method, request_path, body=''):
            timestamp = datetime.now(timezone.utc).strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z'
            sign = generate_signature(timestamp, method, request_path, body)
            return {
                'OK-ACCESS-KEY': api_key,
                'OK-ACCESS-SIGN': sign,
                'OK-ACCESS-TIMESTAMP': timestamp,
                'OK-ACCESS-PASSPHRASE': passphrase,
                'Content-Type': 'application/json'
            }
        
        OKEX_REST_URL = 'https://www.okx.com'
        
        # ç»´æŠ¤æ“ä½œï¼šä¹°å…¥100Uå¹¶ç«‹å³å¹³æ‰
        # è®¡ç®—ä¹°å…¥æ•°é‡ï¼š100U / æ ‡è®°ä»·æ ¼ * æ æ†
        # å…ˆè·å–å½“å‰æ ‡è®°ä»·æ ¼
        position_path = f'/api/v5/account/positions?instType=SWAP&instId={inst_id}'
        headers = get_headers('GET', position_path)
        pos_response = requests.get(
            OKEX_REST_URL + position_path,
            headers=headers,
            timeout=10
        )
        pos_data = pos_response.json()
        
        mark_price = 0
        for position in pos_data.get('data', []):
            if position.get('posSide') == pos_side:
                # å®‰å…¨è½¬æ¢ï¼šå¤„ç†ç©ºå­—ç¬¦ä¸²å’ŒNone
                mark_px_str = position.get('markPx', '0')
                try:
                    mark_price = float(mark_px_str) if mark_px_str and mark_px_str != '' else 0
                except (ValueError, TypeError):
                    mark_price = 0
                break
        
        if mark_price == 0:
            # å¦‚æœæ²¡æœ‰æŒä»“ï¼ŒæŸ¥è¯¢è¡Œæƒ…è·å–ä»·æ ¼
            ticker_path = f'/api/v5/market/ticker?instId={inst_id}'
            ticker_response = requests.get(
                OKEX_REST_URL + ticker_path,
                timeout=10
            )
            ticker_data = ticker_response.json()
            if ticker_data.get('code') == '0' and ticker_data.get('data'):
                # å®‰å…¨è½¬æ¢ï¼šå¤„ç†ç©ºå­—ç¬¦ä¸²å’ŒNone
                last_price_str = ticker_data['data'][0].get('last', '0')
                try:
                    mark_price = float(last_price_str) if last_price_str and last_price_str != '' else 0
                except (ValueError, TypeError):
                    mark_price = 0
        
        if mark_price == 0:
            return jsonify({
                'success': False,
                'message': f'æ— æ³•è·å–æ ‡è®°ä»·æ ¼ï¼Œæ£€æŸ¥æŒä»“å’Œè¡Œæƒ…æ•°æ®'
            })
        
        print(f"ğŸ¯ å­è´¦æˆ·ç»´æŠ¤: {account_name} {inst_id} {pos_side}")
        print(f"   æ ‡è®°ä»·æ ¼: {mark_price}")
        print(f"   ç»´æŠ¤é‡‘é¢: {maintenance_amount}U")
        print(f"   ç›®æ ‡ä¿è¯é‡‘: {target_margin}U")
        print(f"   æ æ†: {sub_account.get('leverage', 10)}x")
        
        # è®¡ç®—ä¹°å…¥æ•°é‡ï¼šä½¿ç”¨åŠ¨æ€ç»´æŠ¤é‡‘é¢
        # pos_size = maintenance_amount * lever / mark_price
        lever = int(sub_account.get('leverage', 10))
        order_size = (maintenance_amount * lever) / mark_price
        
        # å‘ä¸‹å–æ•´åˆ°åˆçº¦æœ€å°å•ä½
        import math
        order_size = math.floor(order_size)
        
        # è®¡ç®—å¹³ä»“æ•°é‡ï¼šä¿ç•™target_marginå¯¹åº”çš„ä»“ä½
        # ä¿ç•™çš„ä»“ä½ = target_margin * lever / mark_price
        keep_size = math.floor((target_margin * lever) / mark_price)
        close_size = order_size - keep_size
        
        if close_size < 0:
            close_size = 0  # å¦‚æœè®¡ç®—å‡ºè´Ÿæ•°ï¼Œä¸å¹³ä»“
        
        # ç¬¬é›¶æ­¥ï¼šå‘é€ä»“ä»“ä½å¢åŠ ä¿è¯é‡‘ï¼ˆé€ä»“å¿…é¡»ï¼‰
        # è®¡ç®—æ‰€éœ€ä¿è¯é‡‘ï¼šç»´æŠ¤é‡‘é¢ / æ æ† + æ‰‹ç»­è´¹ç¼“å†²ï¼ˆ3%ï¼‰
        required_margin = maintenance_amount / lever * 1.03  # åŠ 3%æ‰‹ç»­è´¹å’Œæ»‘ç‚¹ç¼“å†²
        
        margin_path = '/api/v5/account/position/margin-balance'
        margin_body = {
            'instId': inst_id,
            'posSide': pos_side,
            'type': 'add',  # å¢åŠ ä¿è¯é‡‘
            'amt': str(round(required_margin, 2)),
            'ccy': 'USDT'
        }
        
        print(f"ğŸ’° å¢åŠ é€ä»“ä¿è¯é‡‘: {required_margin:.2f} USDT åˆ° {inst_id} {pos_side}")
        headers = get_headers('POST', margin_path, margin_body)
        margin_response = requests.post(
            OKEX_REST_URL + margin_path,
            headers=headers,
            json=margin_body,
            timeout=10
        )
        
        margin_result = margin_response.json()
        print(f"ğŸ“¥ ä¿è¯é‡‘å¢åŠ å“åº”: code={margin_result.get('code')}, msg={margin_result.get('msg')}")
        
        # å¦‚æœä¿è¯é‡‘å¢åŠ å¤±è´¥ï¼Œç»§ç»­å°è¯•ï¼ˆå¯èƒ½å·²ç»æœ‰è¶³å¤Ÿä¿è¯é‡‘æˆ–æ˜¯æ–°ä»“ä½ï¼‰
        if margin_result.get('code') != '0':
            print(f"âš ï¸  ä¿è¯é‡‘å¢åŠ å¤±è´¥ï¼ˆå¯èƒ½æ˜¯æ–°ä»“ä½æˆ–å·²æœ‰è¶³å¤Ÿä¿è¯é‡‘ï¼‰: {margin_result.get('msg')}")
        else:
            print(f"âœ… ä¿è¯é‡‘å¢åŠ æˆåŠŸ")
            # ç­‰å¾…ä¿è¯é‡‘ç”Ÿæ•ˆ
            time.sleep(1)
        
        # ç¬¬ä¸€æ­¥ï¼šå¼€ä»“
        order_path = '/api/v5/trade/order'
        side = 'sell' if pos_side == 'short' else 'buy'
        
        open_order_body = {
            'instId': inst_id,
            'tdMode': 'isolated',  # é€ä»“æ¨¡å¼ï¼šæ¯ä¸ªæŒä»“ç‹¬ç«‹ä¿è¯é‡‘
            'side': side,
            'posSide': pos_side,
            'ordType': 'market',
            'sz': str(order_size)
            # å…¨ä»“æ¨¡å¼ä¸éœ€è¦æŒ‡å®šæ æ†ï¼Œä½¿ç”¨è´¦æˆ·çº§åˆ«æ æ†
        }
        
        headers = get_headers('POST', order_path, open_order_body)
        open_response = requests.post(
            OKEX_REST_URL + order_path,
            headers=headers,
            json=open_order_body,
            timeout=10
        )
        
        open_result = open_response.json()
        
        # è¯¦ç»†æ—¥å¿—ï¼šæ‰“å°OKExå“åº”
        print(f"ğŸ“¤ å¼€ä»“è¯·æ±‚: {open_order_body}")
        print(f"ğŸ“¥ OKExå“åº”: code={open_result.get('code')}, msg={open_result.get('msg')}")
        if open_result.get('code') != '0':
            print(f"âŒ å®Œæ•´å“åº”: {open_result}")
        
        if open_result.get('code') != '0':
            return jsonify({
                'success': False,
                'message': f"å¼€ä»“å¤±è´¥: {open_result.get('msg', 'æœªçŸ¥é”™è¯¯')}",
                'error_code': open_result.get('code'),
                'full_response': str(open_result)  # æ·»åŠ å®Œæ•´å“åº”
            })
        
        open_order_id = open_result['data'][0]['ordId']
        
        # ç­‰å¾…è®¢å•æˆäº¤
        import time
        time.sleep(2)
        
        # ç¬¬äºŒæ­¥ï¼šå¹³æ‰å¤šä½™ä»“ä½ï¼Œä¿ç•™target_marginå¯¹åº”çš„æ•°é‡
        # close_sizeå·²ç»åœ¨å‰é¢è®¡ç®—å¥½äº†
        close_side = 'buy' if pos_side == 'short' else 'sell'
        
        close_order_body = {
            'instId': inst_id,
            'tdMode': 'isolated',  # é€ä»“æ¨¡å¼
            'side': close_side,
            'posSide': pos_side,
            'ordType': 'market',
            'sz': str(close_size)
        }
        
        headers = get_headers('POST', order_path, close_order_body)
        close_response = requests.post(
            OKEX_REST_URL + order_path,
            headers=headers,
            json=close_order_body,
            timeout=10
        )
        
        close_result = close_response.json()
        
        if close_result.get('code') != '0':
            return jsonify({
                'success': False,
                'message': f"å¹³ä»“å¤±è´¥: {close_result.get('msg', 'æœªçŸ¥é”™è¯¯')} (å¼€ä»“è®¢å•ID: {open_order_id})",
                'error_code': close_result.get('code'),
                'open_order_id': open_order_id
            })
        
        close_order_id = close_result['data'][0]['ordId']
        
        # ç»´æŠ¤æˆåŠŸï¼Œæ›´æ–°ç»´æŠ¤æ¬¡æ•°
        if record.get('date') != today_date:
            # æ–°çš„ä¸€å¤©ï¼Œé‡ç½®æ¬¡æ•°
            record = {
                'count': 1,
                'date': today_date,
                'last_maintenance': now_beijing.strftime('%Y-%m-%d %H:%M:%S')
            }
        else:
            # åŒä¸€å¤©ï¼Œå¢åŠ æ¬¡æ•°
            record['count'] = record.get('count', 0) + 1
            record['last_maintenance'] = now_beijing.strftime('%Y-%m-%d %H:%M:%S')
        
        maintenance_data[record_key] = record
        
        # ä¿å­˜æ›´æ–°åçš„æ•°æ®
        with open(maintenance_file, 'w', encoding='utf-8') as f:
            json_lib.dump(maintenance_data, f, ensure_ascii=False, indent=2)
        
        return jsonify({
            'success': True,
            'message': f'ç»´æŠ¤æˆåŠŸï¼ä»Šæ—¥ç¬¬{record["count"]}æ¬¡ç»´æŠ¤',
            'data': {
                'account_name': account_name,
                'inst_id': inst_id,
                'pos_side': pos_side,
                'open_order_id': open_order_id,
                'close_order_id': close_order_id,
                'order_size': order_size,
                'close_size': close_size,
                'today_count': record['count'],
                'max_count': max_count
            }
        })
        
    except Exception as e:
        import traceback
        return jsonify({
            'success': False,
            'message': f'ç»´æŠ¤å¤±è´¥: {str(e)}',
            'traceback': traceback.format_exc()
        })

@app.route('/api/anchor/close-sub-account-position', methods=['POST'])
def close_sub_account_position():
    """å­è´¦æˆ·å¹³ä»“ï¼šéƒ¨åˆ†æˆ–å…¨éƒ¨å¹³ä»“"""
    try:
        import requests
        import hmac
        import base64
        import hashlib
        import json as json_lib
        from datetime import datetime, timezone
        from position_close_guard import validate_close_request, MIN_KEEP_MARGIN
        
        data = request.json
        account_name = data.get('account_name')
        inst_id = data.get('inst_id')
        pos_side = data.get('pos_side')
        close_size = float(data.get('close_size', 0))
        reason = data.get('reason', 'æ‰‹åŠ¨å¹³ä»“')
        
        if not all([account_name, inst_id, pos_side, close_size]):
            return jsonify({
                'success': False,
                'message': 'ç¼ºå°‘å¿…è¦å‚æ•°'
            })
        
        # è¯»å–å­è´¦æˆ·é…ç½®
        with open('sub_account_config.json', 'r', encoding='utf-8') as f:
            config = json_lib.load(f)
        
        # æŸ¥æ‰¾å¯¹åº”çš„å­è´¦æˆ·
        sub_account = None
        for acc in config.get('sub_accounts', []):
            if acc['account_name'] == account_name:
                sub_account = acc
                break
        
        if not sub_account:
            return jsonify({
                'success': False,
                'message': f'æœªæ‰¾åˆ°å­è´¦æˆ·: {account_name}'
            })
        
        api_key = sub_account['api_key']
        secret_key = sub_account['secret_key']
        passphrase = sub_account['passphrase']
        
        # OKEx APIç­¾åå‡½æ•°
        def generate_signature(timestamp, method, request_path, body=''):
            if body:
                body = json_lib.dumps(body)
            message = timestamp + method + request_path + body
            mac = hmac.new(
                bytes(secret_key, encoding='utf8'),
                bytes(message, encoding='utf-8'),
                digestmod=hashlib.sha256
            )
            return base64.b64encode(mac.digest()).decode()
        
        def get_headers(method, request_path, body=''):
            timestamp = datetime.now(timezone.utc).strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z'
            sign = generate_signature(timestamp, method, request_path, body)
            return {
                'OK-ACCESS-KEY': api_key,
                'OK-ACCESS-SIGN': sign,
                'OK-ACCESS-TIMESTAMP': timestamp,
                'OK-ACCESS-PASSPHRASE': passphrase,
                'Content-Type': 'application/json'
            }
        
        # OKEx API URL
        OKEX_REST_URL = 'https://www.okx.com'
        
        # ğŸ›¡ï¸ åº•ä»“ä¿æŠ¤ï¼šè·å–å½“å‰æŒä»“ä¿¡æ¯
        positions_path = '/api/v5/account/positions'
        positions_params = f'?instType=SWAP&instId={inst_id}'
        positions_headers = get_headers('GET', positions_path + positions_params)
        positions_response = requests.get(
            OKEX_REST_URL + positions_path + positions_params,
            headers=positions_headers,
            timeout=10
        )
        positions_data = positions_response.json()
        
        if positions_data.get('code') != '0':
            return jsonify({
                'success': False,
